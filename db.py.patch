# Patch generated by Pyment v0.3.3

--- a/db.py
+++ b/db.py
@@ -18,22 +18,7 @@
 
 
 class Archive(object):
-    """
-    The central object of the archive, which manages the database containing all the available resources.
-
-    Attributes
-    ----------
-    path: Path
-        path at which all resources are located
-    db_path: Path
-        path to the database file
-    docs_path: Path
-        subfolder at which all documents are located
-    secret_path: Path
-        subfolder at which the secret key is located (read-only)
-    secret_key: bytes
-        byte representation of the secret key
-    """
+    """The central object of the archive, which manages the database containing all the available resources."""
     def __init__(self, path: Path):
         """
         Initializes the archive from a given path.
@@ -75,8 +60,14 @@
     @property
     def secret_key(self) -> bytes:
         """Reads the secret key from the corresponding file.
-
-        Will read the file each time instead of permanently storing the secret key."""
+        
+        Will read the file each time instead of permanently storing the secret key.
+
+        Args:
+
+        Returns:
+
+        """
         with open(self.secret_path, mode="rb") as file:
             return file.read()
 
@@ -110,29 +101,18 @@
 
 
 def validate_schema(schema: Dict, data: Dict, may_be_partial: bool = False):
-    """
-    Checks whether a given dictionary of data contains all the required keys with corresponding values of the right type.
-
+    """Checks whether a given dictionary of data contains all the required keys with corresponding values of the right type.
+    
     Given some data in form of a dictionary, this function determines whether a given list of required keys corresponding to a specific type is contained. There may be cases where a only a subset of the schema is required and missing keys are allowed, but any combinations contradicting the given schema will result in an exception.
 
-    Parameters
-    ----------
-        schema: Dict
-            contains a mapping of attribute name to required type
-        data: Dict
-            data to be checked in form of a simple dictionary
-        may_be_partial: bool
-            determines whether part of the schema may be missing from the given data
-
-    Returns
-    -------
-        bool
-            True if data conforms to the schema, False otherwise.
-
-    Raises
-    ------
-    BadRequest
-        if data is empty, not a dictionary, misses a required attribute or has an attribute of a different type than required
+    Args:
+      schema: Dict: 
+      data: Dict: 
+      may_be_partial: bool:  (Default value = False)
+
+    Returns:
+
+    
     """
     if data is None:
         raise BadRequest("Request body may not be empty")
@@ -154,14 +134,7 @@
 
 
 class Resource(object):
-    """
-    Any kind of resource associated with a list of attributes, which is stored in the database and accessible via the public API.
-
-    Attributes
-    ----------
-    entry_id: int
-        numerical id corresponding to one unique resource
-    """
+    """Any kind of resource associated with a list of attributes, which is stored in the database and accessible via the public API."""
     ATTRIBUTE_SCHEMA = dict()
     TABLE_NAME = ""
     RESOURCE_PATH = ""
@@ -171,27 +144,67 @@
 
     @property
     def entry_id(self) -> int:
+        """ """
         return self.__entry_id
 
     @classmethod
     def validate_data(cls, data: Dict, may_be_partial: bool = False):
+        """
+
+        Args:
+          data: Dict: 
+          may_be_partial: bool:  (Default value = False)
+
+        Returns:
+
+        
+        """
         validate_schema(cls.ATTRIBUTE_SCHEMA, data, may_be_partial)
 
     @classmethod
     def register_resource(cls, app: Flask):
+        """
+
+        Args:
+          app: Flask: 
+
+        Returns:
+
+        
+        """
         def get_entry(entry_id: int) -> Resource:
+            """
+
+            Args:
+              entry_id: int: 
+
+            Returns:
+
+            
+            """
             entry = cls.get_entry(entry_id)
             if entry is None:
                 raise NotFound("The requested resource does not exist")
             return entry
 
         def commit_and_make_response(data: Dict, status=200) -> Response:
+            """
+
+            Args:
+              data: Dict: 
+              status:  (Default value = 200)
+
+            Returns:
+
+            
+            """
             response = make_response(data, status)
             g.archive.commit()
             return response
 
         @app.get(f"{cls.RESOURCE_PATH}", endpoint=f"GET {cls.RESOURCE_PATH}", strict_slashes=False)
         def get_all():
+            """ """
             return make_response({
                 entry.entry_id: entry.dict
                 for entry in cls.get_entries()
@@ -199,11 +212,21 @@
 
         @app.get(f"{cls.RESOURCE_PATH}/<int:entry_id>", endpoint=f"GET {cls.RESOURCE_PATH}/id")
         def get(entry_id: int):
+            """
+
+            Args:
+              entry_id: int: 
+
+            Returns:
+
+            
+            """
             return make_response(cls.get_entry(entry_id).dict)
 
         @app.post(f"{cls.RESOURCE_PATH}", endpoint=f"POST {cls.RESOURCE_PATH}", strict_slashes=False)
         @login_required
         def post():
+            """ """
             data = request.get_json()
             cls.validate_data(data)
             entry = cls.new_entry(data)
@@ -212,6 +235,15 @@
         @app.patch(f"{cls.RESOURCE_PATH}/<int:entry_id>", endpoint=f"PATCH {cls.RESOURCE_PATH}/id")
         @login_required
         def patch(entry_id: int):
+            """
+
+            Args:
+              entry_id: int: 
+
+            Returns:
+
+            
+            """
             data = request.get_json()
             cls.validate_data(data, may_be_partial=True)
             get_entry(entry_id).update(data)
@@ -220,15 +252,43 @@
         @app.delete(f"{cls.RESOURCE_PATH}/<int:entry_id>", endpoint=f"DELETE {cls.RESOURCE_PATH}/id")
         @login_required
         def delete(entry_id: int):
+            """
+
+            Args:
+              entry_id: int: 
+
+            Returns:
+
+            
+            """
             get_entry(entry_id).delete()
             return commit_and_make_response({})
 
     @classmethod
     def get_entries(cls: Type[R]) -> List[R]:
+        """
+
+        Args:
+          cls: Type[R]: 
+
+        Returns:
+
+        
+        """
         return [cls(entry_id[0]) for entry_id in g.archive.db.execute(f"select ID from {cls.TABLE_NAME}")]
 
     @classmethod
     def get_entry(cls: Type[R], entry_id: int) -> Optional[R]:
+        """
+
+        Args:
+          cls: Type[R]: 
+          entry_id: int: 
+
+        Returns:
+
+        
+        """
         cursor = g.archive.db.execute(f"select count(ID) from {cls.TABLE_NAME} where ID = ?", (entry_id,))
         if cursor.fetchone()[0] == 1:
             return cls(entry_id)
@@ -237,33 +297,41 @@
 
     @classmethod
     def new_entry(cls, data: Dict) -> 'Resource':
+        """
+
+        Args:
+          data: Dict: 
+
+        Returns:
+
+        
+        """
         raise NotImplementedError
 
     @property
     def dict(self) -> Dict:
+        """ """
         raise NotImplementedError
 
     def update(self, data: Dict):
+        """
+
+        Args:
+          data: Dict: 
+
+        Returns:
+
+        
+        """
         raise NotImplementedError
 
     def delete(self):
+        """ """
         raise NotImplementedError
 
 
 class Document(Resource):
-    """
-    A file of specific media type that is stored on disk.
-
-    Attributes
-    ---------
-    filename: str
-        Filename of the document
-    downloadable: bool
-        TODO: "including unauthorized users" - kinda self-contradicting more like "not privileged users"
-        Whether the document is downloadable for all (including currently not logged in) users
-    content_type: str
-        The media type of the file. Allowed content types are specified in the protocol.
-    """
+    """A file of specific media type that is stored on disk."""
     ATTRIBUTE_SCHEMA = {
         "filename": str,
         "downloadable": bool,
@@ -274,6 +342,16 @@
 
     @classmethod
     def validate_data(cls, data: Dict, may_be_partial: bool = False):
+        """
+
+        Args:
+          data: Dict: 
+          may_be_partial: bool:  (Default value = False)
+
+        Returns:
+
+        
+        """
         super(Document, cls).validate_data(data, may_be_partial)
         allowed_content_types = [
             "application/msword", "application/pdf", "application/x-latex", "image/png", "image/jpeg", "image/gif",
@@ -286,9 +364,19 @@
 
     @classmethod
     def register_resource(cls, app: Flask):
+        """
+
+        Args:
+          app: Flask: 
+
+        Returns:
+
+        
+        """
         super(Document, cls).register_resource(app)
 
         def get_requested_document() -> Document:
+            """ """
             try:
                 doc_id = int(request.args["id"])
             except KeyError:
@@ -300,6 +388,7 @@
         @app.post("/v1/upload")
         @login_required
         def upload_document():
+            """ """
             doc = get_requested_document()
 
             if request.content_type != doc.content_type:
@@ -313,6 +402,7 @@
 
         @app.get("/v1/download")
         def download_document():
+            """ """
             doc = get_requested_document()
 
             # Check if the document belongs to an invisible item or is not downloadable.
@@ -324,6 +414,15 @@
 
     @classmethod
     def get_entries(cls: R) -> List[R]:
+        """
+
+        Args:
+          cls: R: 
+
+        Returns:
+
+        
+        """
         entries: List['Document'] = super(Document, cls).get_entries()
         if not current_user.is_authenticated:
             entries = [entry for entry in entries if entry.may_be_accessed()]
@@ -331,6 +430,16 @@
 
     @classmethod
     def get_entry(cls: R, entry_id: int) -> Optional[R]:
+        """
+
+        Args:
+          cls: R: 
+          entry_id: int: 
+
+        Returns:
+
+        
+        """
         entry: 'Document' = super(Document, cls).get_entry(entry_id)
         if not entry.may_be_accessed():
             raise Unauthorized("You are not allowed to access this resource")
@@ -338,6 +447,15 @@
 
     @classmethod
     def new_entry(cls, data: Dict) -> 'Document':
+        """
+
+        Args:
+          data: Dict: 
+
+        Returns:
+
+        
+        """
         cls.validate_data(data)
         cursor = g.archive.db.execute(
             "insert into Documents(filename, downloadable, content_type) values (?, ?, ?)",
@@ -347,6 +465,7 @@
 
     @property
     def dict(self) -> Dict:
+        """ """
         return {
             "filename": self.filename,
             "downloadable": self.downloadable,
@@ -354,6 +473,15 @@
         }
 
     def update(self, data: Dict):
+        """
+
+        Args:
+          data: Dict: 
+
+        Returns:
+
+        
+        """
         self.validate_data(data, may_be_partial=True)
         if "filename" in data:
             self.filename = data["filename"]
@@ -367,6 +495,7 @@
         g.archive.db.execute("delete from Documents where ID=?", (self.entry_id,))
 
     def may_be_accessed(self) -> bool:
+        """ """
         if current_user.is_authenticated:
             return True
         cursor = g.archive.db.execute("""
@@ -378,34 +507,65 @@
 
     @property
     def filename(self) -> str:
+        """ """
         cursor = g.archive.db.execute("select filename from Documents where ID=?", (self.entry_id,))
         return cursor.fetchone()[0]
 
     @filename.setter
     def filename(self, new_name: str):
+        """
+
+        Args:
+          new_name: str: 
+
+        Returns:
+
+        
+        """
         g.archive.db.execute("update Documents set filename=? where ID=?", (new_name, self.entry_id))
 
     @property
     def content_type(self) -> str:
+        """ """
         cursor = g.archive.db.execute("select content_type from Documents where ID=?", (self.entry_id,))
         return cursor.fetchone()[0]
 
     @content_type.setter
     def content_type(self, new_type: str):
+        """
+
+        Args:
+          new_type: str: 
+
+        Returns:
+
+        
+        """
         g.archive.db.execute("update Documents set content_type=? where ID=?", (new_type, self.entry_id))
 
     @property
     def downloadable(self) -> bool:
+        """ """
         cursor = g.archive.db.execute("select downloadable from Documents where ID=?", (self.entry_id,))
         return cursor.fetchone()[0] == 1
 
     @downloadable.setter
     def downloadable(self, downloadable: bool):
+        """
+
+        Args:
+          downloadable: bool: 
+
+        Returns:
+
+        
+        """
         downloadable = 1 if downloadable else 0
         g.archive.db.execute("update Documents set downloadable=? where ID=?", (downloadable, self.entry_id))
 
     @property
     def path(self) -> Path:
+        """ """
         return g.archive.docs_path / Path(str(self.entry_id))
 
     def __eq__(self, other: 'Document') -> bool:
@@ -419,16 +579,7 @@
 
 
 class Course(Resource):
-    """
-    A university course associated with a number of documents.
-
-    Attributes
-    ----------
-    long_name : str
-        Full name of the course
-    short_name : str
-        Abbreviated name for the course
-    """
+    """A university course associated with a number of documents."""
     ATTRIBUTE_SCHEMA = {
         "long_name": str,
         "short_name": str
@@ -438,6 +589,15 @@
 
     @classmethod
     def new_entry(cls, data: Dict) -> 'Course':
+        """
+
+        Args:
+          data: Dict: 
+
+        Returns:
+
+        
+        """
         cls.validate_data(data)
         cursor = g.archive.db.execute(
             "insert into Courses(long_name, short_name) values (?, ?)",
@@ -447,12 +607,22 @@
 
     @property
     def dict(self) -> Dict:
+        """ """
         return {
             "long_name": self.long_name,
             "short_name": self.short_name
         }
 
     def update(self, data: Dict):
+        """
+
+        Args:
+          data: Dict: 
+
+        Returns:
+
+        
+        """
         self.validate_data(data, may_be_partial=True)
         if "long_name" in data:
             self.long_name = data["long_name"]
@@ -460,24 +630,45 @@
             self.short_name = data["short_name"]
 
     def delete(self):
+        """ """
         g.archive.db.execute("delete from Courses where ID=?", (self.entry_id,))
 
     @property
     def long_name(self) -> str:
+        """ """
         cursor = g.archive.db.execute("select long_name from Courses where ID=?", (self.entry_id,))
         return cursor.fetchone()[0]
 
     @long_name.setter
     def long_name(self, new_name):
+        """
+
+        Args:
+          new_name: 
+
+        Returns:
+
+        
+        """
         g.archive.db.execute("update Courses set long_name=? where ID=?", (new_name, self.entry_id))
 
     @property
     def short_name(self) -> str:
+        """ """
         cursor = g.archive.db.execute("select short_name from Courses where ID=?", (self.entry_id,))
         return cursor.fetchone()[0]
 
     @short_name.setter
     def short_name(self, new_name):
+        """
+
+        Args:
+          new_name: 
+
+        Returns:
+
+        
+        """
         g.archive.db.execute("update Courses set short_name=? where ID=?", (new_name, self.entry_id))
 
     def __eq__(self, other: 'Course') -> bool:
@@ -491,14 +682,7 @@
 
 
 class Folder(Resource):
-    """Representation of the physical folder an item may be found in.
-
-    Attributes
-    ----------
-    name: str
-        name of the folder
-
-    """
+    """Representation of the physical folder an item may be found in."""
     ATTRIBUTE_SCHEMA = {
         "name": str
     }
@@ -507,6 +691,15 @@
 
     @classmethod
     def new_entry(cls, data: Dict) -> 'Folder':
+        """
+
+        Args:
+          data: Dict: 
+
+        Returns:
+
+        
+        """
         cls.validate_data(data)
         cursor = g.archive.db.execute(
             "insert into Folders(name) values (?)",
@@ -516,25 +709,46 @@
 
     @property
     def dict(self) -> Dict:
+        """ """
         return {
             "name": self.name
         }
 
     def update(self, data: Dict):
+        """
+
+        Args:
+          data: Dict: 
+
+        Returns:
+
+        
+        """
         self.validate_data(data, may_be_partial=True)
         if "name" in data:
             self.name = data["name"]
 
     def delete(self):
+        """ """
         g.archive.db.execute("delete from Folders where ID=?", (self.entry_id,))
 
     @property
     def name(self) -> str:
+        """ """
         cursor = g.archive.db.execute("select name from Folders where ID=?", (self.entry_id,))
         return cursor.fetchone()[0]
 
     @name.setter
     def name(self, new_name):
+        """
+
+        Args:
+          new_name: 
+
+        Returns:
+
+        
+        """
         g.archive.db.execute("update Folders set name=? where ID=?", (new_name, self.entry_id))
 
     def __eq__(self, other: 'Folder'):
@@ -549,15 +763,7 @@
 
 
 class Author(Resource):
-    """Author responsible for a document.
-
-    Attributes
-    ----------
-    entry_id: int
-        id of the author in the database
-    name: str
-        Name of the author
-    """
+    """Author responsible for a document."""
     ATTRIBUTE_SCHEMA = {
         "name": str
     }
@@ -566,6 +772,15 @@
 
     @classmethod
     def new_entry(cls, data: Dict) -> 'Author':
+        """
+
+        Args:
+          data: Dict: 
+
+        Returns:
+
+        
+        """
         cursor = g.archive.db.execute("insert into Authors(name) values (?)", (data["name"],))
         return Author(cursor.lastrowid)
 
@@ -577,19 +792,39 @@
         }
 
     def update(self, data: Dict):
+        """
+
+        Args:
+          data: Dict: 
+
+        Returns:
+
+        
+        """
         if "name" in data:
             self.name = data["name"]
 
     def delete(self):
+        """ """
         g.archive.db.execute("delete from Authors where ID=?", (self.entry_id,))
 
     @property
     def name(self) -> str:
+        """ """
         cursor = g.archive.db.execute("select name from Authors where ID=?", (self.entry_id,))
         return cursor.fetchone()[0]
 
     @name.setter
     def name(self, new_name):
+        """
+
+        Args:
+          new_name: 
+
+        Returns:
+
+        
+        """
         g.archive.db.execute("update Authors set name=? where ID=?", (new_name, self.entry_id))
 
     def __eq__(self, other: 'Author'):
@@ -603,24 +838,7 @@
 
 
 class Item(Resource):
-    """
-    A concrete lecture or exam consisting of multiple documents, that can be used to prepare for a number of courses.
-
-    Attributes
-    ----------
-    entry_id: int
-        id of the item in the database.
-    name: str
-        Name of the concrete lecture or exam.
-    documents: List
-        List of documents associated with the item.
-    courses: List
-        List of courses that the item can be used to prepare for.
-    folders: List
-        physical folder(s) the item is available in.
-    visible: bool
-        Whether the item is visible to unauthorized users.
-    """
+    """A concrete lecture or exam consisting of multiple documents, that can be used to prepare for a number of courses."""
     ATTRIBUTE_SCHEMA = {
         "name": str,
         # date is not included as it may be None and the normal check can't deal with that.
@@ -637,19 +855,16 @@
     def validate_data(cls, data: Dict, may_be_partial: bool = False):
         """Checks whether the dictionary representation of an item results in a valid item.
 
-        Parameters
-        ----------
-        cls : type
-            Item type
-        data: Dict
-            dictionary mapping attribute names to their respective values
-        may_be_partial: bool, optional
-            Whether part of the attributes may be missing
-
-        Raises
-        ------
-        BadRequest
-            If date attribute is missing, not a string or not ISO-formatted or if one of the other attributes contains entries with invalid entry_id
+        Args:
+          cls(type): Item type
+          data(Dict): dictionary mapping attribute names to their respective values
+          may_be_partial(bool, optional): Whether part of the attributes may be missing
+          data: Dict: 
+          may_be_partial: bool:  (Default value = False)
+
+        Returns:
+
+        
         """
         super(Item, cls).validate_data(data, may_be_partial)
 
@@ -666,6 +881,16 @@
             raise BadRequest("Attribute \"date\" is missing")
 
         def validate_attribute(table_name, attribute_name):
+            """
+
+            Args:
+              table_name: 
+              attribute_name: 
+
+            Returns:
+
+            
+            """
             if may_be_partial and attribute_name not in data:
                 return
 
@@ -685,6 +910,15 @@
 
     @classmethod
     def get_entries(cls: R) -> List[R]:
+        """
+
+        Args:
+          cls: R: 
+
+        Returns:
+
+        
+        """
         entries: List['Item'] = super(Item, cls).get_entries()
         if not current_user.is_authenticated:
             entries = [entry for entry in entries if entry.visible]
@@ -692,6 +926,16 @@
 
     @classmethod
     def get_entry(cls: R, entry_id: int) -> Optional[R]:
+        """
+
+        Args:
+          cls: R: 
+          entry_id: int: 
+
+        Returns:
+
+        
+        """
         entry: 'Item' = super(Item, cls).get_entry(entry_id)
         if current_user.is_authenticated or entry.visible:
             return entry
@@ -700,6 +944,15 @@
 
     @classmethod
     def new_entry(cls, data: Dict) -> 'Item':
+        """
+
+        Args:
+          data: Dict: 
+
+        Returns:
+
+        
+        """
         cursor = g.archive.db.execute("insert into Items(name, date, visible) values (?, ?, ?)",
                                       (data["name"], data["date"], data["visible"]))
         item = Item(cursor.lastrowid)
@@ -723,6 +976,15 @@
         }
 
     def update(self, data: Dict):
+        """
+
+        Args:
+          data: Dict: 
+
+        Returns:
+
+        
+        """
         if "name" in data:
             self.name = data["name"]
         if "date" in data:
@@ -739,6 +1001,7 @@
             self.visible = data["visible"]
 
     def delete(self):
+        """ """
         g.archive.db.execute("delete from Items where ID=?", (self.entry_id,))
 
     @property
@@ -749,7 +1012,14 @@
 
     @name.setter
     def name(self, new_name: str):
-        """Updates the name attribute of all entries with maching entry_id."""
+        """Updates the name attribute of all entries with maching entry_id.
+
+        Args:
+          new_name: str: 
+
+        Returns:
+
+        """
         g.archive.db.execute("update Items set name=? where ID=?", (new_name, self.entry_id))
 
     @property
@@ -760,7 +1030,14 @@
 
     @date.setter
     def date(self, new_date: Optional[str]):
-        """Updates the date attribute of all entries with maching entry_id."""
+        """Updates the date attribute of all entries with maching entry_id.
+
+        Args:
+          new_date: Optional[str]: 
+
+        Returns:
+
+        """
         g.archive.db.execute("update Items set date=? where ID=?", (new_date, self.entry_id))
 
     @property
@@ -771,7 +1048,14 @@
 
     @documents.setter
     def documents(self, new_documents: List[Document]):
-        """Replaces the list of documents associated with this item with the given list of documents."""
+        """Replaces the list of documents associated with this item with the given list of documents.
+
+        Args:
+          new_documents: List[Document]: 
+
+        Returns:
+
+        """
         g.archive.db.execute("delete from ItemDocumentMap where ItemID=?", (self.entry_id,))
         g.archive.db.executemany(
             "insert into ItemDocumentMap(ItemID, DocumentID) values (?, ?)",
@@ -786,7 +1070,14 @@
 
     @courses.setter
     def courses(self, new_courses: List[Course]):
-        """Replaces the list of courses associated with this item with the given list of courses."""
+        """Replaces the list of courses associated with this item with the given list of courses.
+
+        Args:
+          new_courses: List[Course]: 
+
+        Returns:
+
+        """
         g.archive.db.execute("delete from ItemCourseMap where ItemID=?", (self.entry_id,))
         g.archive.db.executemany(
             "insert into ItemCourseMap(ItemID, CourseID) values (?, ?)",
@@ -801,7 +1092,14 @@
 
     @authors.setter
     def authors(self, new_authors: List[Author]):
-        """Replaces the list of authors associated with this item with the given list of authors."""
+        """Replaces the list of authors associated with this item with the given list of authors.
+
+        Args:
+          new_authors: List[Author]: 
+
+        Returns:
+
+        """
         g.archive.db.execute("delete from ItemAuthorMap where ItemID=?", (self.entry_id,))
         g.archive.db.executemany(
             "insert into ItemAuthorMap(ItemID, AuthorID) values (?, ?)",
@@ -816,7 +1114,14 @@
 
     @folders.setter
     def folders(self, new_folders: List[Folder]):
-        """Replaces the list of folders associated with this item with the given list of folders."""
+        """Replaces the list of folders associated with this item with the given list of folders.
+
+        Args:
+          new_folders: List[Folder]: 
+
+        Returns:
+
+        """
         g.archive.db.execute("delete from ItemFolderMap where ItemID=?", (self.entry_id,))
         g.archive.db.executemany(
             "insert into ItemFolderMap(ItemID, FolderID) values (?, ?)",
@@ -831,7 +1136,14 @@
 
     @visible.setter
     def visible(self, new_visible: bool):
-        """Updates the visible attribute of this item to the given state."""
+        """Updates the visible attribute of this item to the given state.
+
+        Args:
+          new_visible: bool: 
+
+        Returns:
+
+        """
         new_visible = 1 if new_visible else 0
         g.archive.db.execute("update Items set visible=? where ID=?", (new_visible, self.entry_id))
 
